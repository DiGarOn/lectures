#include <iostream>

using namespace std;

/*
C++11/14

программно-апаратный стек - (в арихитектуре фон-неймона принцип адресности, 
    принцип последовательности) (для того, Чтобы было удобнее работать с программами)
    есть стек поинтер - адрес памяти, где начинается стэк 
    стэк - это парадигма хранения данных. "часть памяти используется по принципам стека"
соглашение о вызовах в С++ - о передаче данных в функцию (Аргументы функции передаются через стек, справа налево)

передча бывает через стек и через регистры (calloing convemtions)
у стека - справа/слева
у регистров - sisV/fastcall

С и С++ используют Стек слева (f(a,b,c) -> c<-b<-a) это для того, чтобы при использовании 
    void f(int,int,int, ...) чтобы не разбивать лишний раз стек и просто считывать переменные

в С89, С++98 - auto - локальная переменная с автоматическим временем хранения
с С++11 - автоматический вывод типа переменной (auto)

auto i = {3};
auto d = {3.14};
auto f = [](){return 42;};

int ar[5] = {1,2,3} ... "1,2,3,?,?";
struct s {
    int a;
    char b;
    double c;
};
struct s a = {1,2};

в Си++ производится предварительная проверка на сужение 

сематика перемещения 
&& - Универсальная ссылка  
    (если можно выполнить перемещение - то это парвосторонняя ссылка) (rvalue)
    если нельзя выполнить перемещение - обычная ссылка

& - ссылка (Левосторонняя ) lvalue

1) std::move - шаблон функции (вырождающаяся), которая должна сделать все, для того, чтобы объект можно 
    было переместить, но не переместить (посмотреть у Мэйерса)
2) std::forward - рпозрачная передача (если в функцию приходит правосторонняя ссылка и надо поработать 
    с объектом и передать куда-то насквозь. это шаблон) (отличие от мува - проверяет, можно ли сделать) (у Страуструпа)

про Лабораторную Работу номер 8 (на потоки):
    из нескольких частей:
        шаблон матрицы  + конструкторы 
                        + умножение матриц / скаляров
                        + сравнивание матриц на сопадение (== / !=)
                        + Оператор отрицания (возвращает обратную матрицу)
                        + проверка, единичная матрица или нулевая (со скаляром)
                        + присваивание и тп
                        + статичиские методы, позволяющие создать един. или нулевую
                            матрицу нужного размера
                использовать tsd::thread
            доп задание - на реализацию на posixAPI
             + перегрузка на std::asinc
    Важно!! - читать (Э.Уильямс Паралл. програ. на Си++ в действии 2012)


auto 

*/

int main() {
    


    return 0;
}